webpackJsonp([20935678756217],{438:function(e,t){e.exports={data:{postBySlug:{html:'<h1 id="defining-transformations"><a href="#defining-transformations" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Transformations</h1>\n<p>Transformations allow Optic to convert one type of model into another (i.e. model -> route, route -> form). A Transformation is just a pure Javascript function that takes one type of Schema and returns another.</p>\n<p>Every Transformation needs a <code class="language-text">yields</code> field. This field should indicate what the result of this transformation will be ie "Create Route". Transformations also get an <code class="language-text">input</code> and <code class="language-text">output</code> field which are references to the Schemas they consume and return.</p>\n<p>The code block for a Transformation must contain a function named <code class="language-text">transform</code>. This function will receive a model that is the same type as <code class="language-text">input</code> and will return a model of type <code class="language-text">output</code>. If the function returns an object that doesn’t conform to type output or if the code throws an exception, the Transformation will return an error to the user.</p>\n<div class="gatsby-highlight">\n      <pre class="language-markdown"><code class="language-markdown"><span class="token comment">&lt;!-- Transformation {\n    "yeilds": "Create Route",\n    "id": "schematoroute",\n    "input": "schema",\n    "output": "optic:rest/route"\n  } --></span>\n```javascript\nfunction transform(input) {\n<span class="token code keyword">    const routeName = input.name.toLowerCase()</span>\n<span class="token code keyword">    const route = “/“+routeName</span>\n\n<span class="token code keyword">    const parameters = Object.keys(input.Schema).map(i=> {</span>\n<span class="token code keyword">        return {</span>\n<span class="token code keyword">            in: ‘body’,</span>\n<span class="token code keyword">            name: i</span>\n<span class="token code keyword">        }</span>\n<span class="token code keyword">    })</span>\n\n<span class="token code keyword">    return {</span>\n<span class="token code keyword">        method: “post”,</span>\n<span class="token code keyword">        url: route,</span>\n<span class="token code keyword">        parameters</span>\n<span class="token code keyword">    }</span>\n}\n```</code></pre>\n      </div>\n<h2 id="asking-for-additional-information"><a href="#asking-for-additional-information" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asking for Additional Information</h2>\n<p>Some Transformations will require more information than what you find in its input Schema. For instance, when generating a route, you might want to offer a flag for <code class="language-text">authenticated</code> that affects how that route is rendered.</p>\n<p>Optic Markdown supports asking for additional information through its Ask API. You can ask for a more values by placing an ask call above  your <code class="language-text">transform</code> function. Optic converts these ask calls into an anonymous Schema that users have to respond to in the Editor Window after they select the Transformation.</p>\n<p>The first argument to all of the ask functions is the name of the field. We suggest you make it a valid JS token, so you can reference it with dot notation in your <code class="language-text">transform</code> function.</p>\n<p>The second field is a description. Use this field to give users the details they need to properly answer your questions and inform them of how this information will be used.</p>\n<p>When calling <code class="language-text">forPrimitive</code>, the 3rd argument is required and defines the type you must answer with. Right now <code class="language-text">boolean</code>, <code class="language-text">string</code>, and <code class="language-text">number</code> are allowed. These types follow the same semantics as they do in the <a href="http://json-Schema.org/">JSON Schema</a> Spec.</p>\n<p>When calling <code class="language-text">forlens</code>, the 3rd argument is optional and allows you to filter the Lenses you can answer with to ones that render a certain Schema. There’s a one-to-many relationship between Schemas and Lenses, so often a Transformation will need to ask users which Lens they would like to render the result with. Naturally if you are Transforming something into a Rest Route, you only want to employ Lenses capable of doing that.</p>\n<p>When calling <code class="language-text">for</code>, the 3rd argument is a function that receives the model being transformed. You can process that input and return another JSON schema. This supports asking for data based on the input model.</p>\n<p><strong>Using Answers:</strong>\nAll answers are added to an object which is passed into the <code class="language-text">transform</code> function as the second argument. You can access them with dot or bracket notation as you would any other property.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">ask.forPrimitive(‘ask1’, ‘Description here...’, ‘string’)\nask.forLens(‘ask2’, ‘Description here...’, ‘test:package/Schema’)\nask.forSchema(‘ask3’, ‘Description here...’)\nask.for(‘ask4’, ‘Description here...’, (input)=&gt; {\n  return {}\n})\nfunction transform(input, answers) {\n  answers.ask1 //a primitive of the specified type\n  answers.ask2 //the ID of a compiled Lens, guaranteed to render specified Schema\n  answers.ask3 //a Schema reference\n...\n}</code></pre>\n      </div>\n<h2 id="nested-transformations"><a href="#nested-transformations" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested Transformations</h2>\n<p><strong>The Need:</strong> Most practical Transformations are not going to rely on just one type of Schema or Lens. For instance Routes contain validation, queries, error handling, and responses. It would be tedious if users had to Transform a model into each of those components individually. Many code generators have elected to make larger abstractions RouteWithValidationAndQueryAndResponse, but big abstractions are brittle and go against our design principles.</p>\n<p>Optic addresses this need by allowing users to tap into our internal Render system. Instead of returning a simple model from the <code class="language-text">Transform</code> function, there is an option to return a request for our internal Render system to do something more complex.</p>\n<p>There’s a Generate function in the global scope that you can call from your Transformation.\n<code class="language-text">Generate(SchemaRef, value, {...options})</code>. This function takes the following arguments:</p>\n<ul>\n<li>Schema Reference - The reference to the Schema you would like to render</li>\n<li>value - The value (must conform to the above Schema)</li>\n<li>options - Allow you to configure the render (see below)</li>\n</ul>\n<p>If you return <code class="language-text">Generate(‘optic:js/import’, {definedAs: ‘hello’, pathTo: ‘world’})</code> from your Transform function, Optic will write <code class="language-text">import hello from ‘world’</code> in your code.</p>\n<h3 id="render-options"><a href="#render-options" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Render Options</h3>\n<table>\n<thead>\n<tr>\n<th>field</th>\n<th>default</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lensId (optional)</td>\n<td>1st Lens found with Schema</td>\n<td>The ID of the Lens you want to render with.</td>\n</tr>\n<tr>\n<td>inFile (optional)</td>\n<td>none</td>\n<td>The name of the file Optic we should insert the result into. Current file if not set empty</td>\n</tr>\n<tr>\n<td>tag (optional, only valid for nested Generate calls)</td>\n<td>none</td>\n<td>A unique string used to identify this nested transformation. Used by sync to locate this node in code.</td>\n</tr>\n<tr>\n<td>containers (optional)</td>\n<td>Empty Object</td>\n<td>A map of container names -> \n[\nStagedNode...\n]\n. Use this to fill a Lens container with your own staged nodes. They will be rendered in the order of the array you provide</td>\n</tr>\n<tr>\n<td>variables (optional)</td>\n<td>Empty Object</td>\n<td>A map of variable names and the string value you want them to render with. (ie: {model: ‘user’}) Note that these are implicitly passed from parents to children. So if you set them at the top-most call to \n<code class="language-text">Generate</code>\n they will be passed down the tree and merged/overridden by any variables you set in those children.</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Full Example:</strong>\nModel -> Route Transformation with nested queries and responses.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">ask.forLens(‘queryProvider’, ‘The Lens your want to use for your create query’, ‘optic:query/create-record’)\nfunction transform(input, answers) {\n    var routeName = input.name.toLowerCase();\n\n    var route = “/“ + routeName;\n    var parameters = Object.keys(input.Schema).map(function(i) {\n        return { in: ‘body’,\n            name: i\n        };\n    });\n    var routeDescription = {\n        method: “post”,\n        url: route,\n        parameters: parameters\n    };\n    var queryDescription = {\n        fields: Object.keys(input.Schema).reduce(function(previous, current) {\n            previous[current] = Generate(‘optic:rest/parameter’, { in: ‘body’,\n                name: current\n            });\n            return previous;\n        }, {})\n    };\n\n    const newItemVariable = ‘item’\n\n    return Generate(answers.output, routeDescription, {\n        containers: {\n            “callback”: [Generate(‘optic:mongoose/create-record’, queryDescription, {\n                gearId: answers.queryProvider\n                containers: {\n                  “success”: [\n                    Generate(‘optic:rest/response’, {status: 200}, {\n                      ‘variables’: {\n                        ‘returnObject’: newItemVariable\n                      }\n                    })\n                  ],\n                  “failure”: [\n                    Generate(‘optic:rest/response’, {status: 400})\n                  ]\n                },\n                ‘variables’: {\n                  ‘newObject’: newItemVariable\n                }\n            })]\n        }\n    });\n}</code></pre>\n      </div>\n<p>Input Code:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">const toDo = mongoose.model(‘todo’, new mongoose.Schema({\n    ‘message’: ‘string’,\n    ‘isDone’: ‘string’\n}))</code></pre>\n      </div>\n<p>Transformed into Create Route:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">app.post(‘/todo’, (req, res)=&gt; {\n  new toDo({\n    message: req.body.message,\n    isDone: req.body.isDone\n  }).save((err, item)=&gt; {\n    if (!err) {\n      res.send(200, item)\n    } else {\n      res.send(400, err)\n    }\n  })\n})</code></pre>\n      </div>\n<h2 id="mutating-transformations"><a href="#mutating-transformations" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutating Transformations</h2>\n<p>Optic also supports transformations that change the current code but don\'t generate anything new. We use this in our Redux skill for adding an action to an existing reducer. To use a mutate transformation you have to do two things:</p>\n<ol>\n<li>Omit <code class="language-text">output</code> from your annotation. This lets Optic know it should expect a mutation</li>\n<li>Return a call to the built-in Mutate function. <code class="language-text">return Mutate(...)</code></li>\n</ol>\n<p>In mutation transformations you get a third argument containing Optic\'s internal id for the model you are mutating <code class="language-text">function transform(input, answers, modelId)</code>.</p>\n<p>The <code class="language-text">Mutate</code> function takes the <code class="language-text">modelId</code>, an object containing changes to that node\'s value, and an optional options object.</p>\n<p><code class="language-text">Mutate(modelId, {&quot;pathTo&quot;: &quot;new/value/file.js&quot;})</code></p>\n<p>Here are the additional options you can pass <code class="language-text">Mutate</code></p>\n<ul>\n<li>tags - Used to update child nodes by their tag. `{"tagName": Mutate(newValue, {options})}</li>\n<li>variables - Used to change all instances of a variable within this node and its children. <code class="language-text">{&quot;variableName&quot;: &quot;newValue&quot;)}</code></li>\n<li>variables - Used to change all instances of a variable within this node and its children. <code class="language-text">{&quot;variableName&quot;: &quot;newValue&quot;)}</code></li>\n<li>containers - Used to update the contents of a container. <code class="language-text">{&quot;container&quot;: Empty() || Append([items...]) || Prepend([items...]), ReplaceWith([items...]) || InsertAt(index, [items...])}</code></li>\n</ul>\n<h2 id="multiple-transformation"><a href="#multiple-transformation" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple Transformation</h2>\n<p>You can also create transformations that have multiple outputs. To create a multi-transformation all you have to do is return an array of <code class="language-text">Generate</code> and <code class="language-text">Mutate</code> calls. Optic will apply these changes in the order it receives them. As a matter of best practice perform all your work within the transformation and then return only the final changes to be pressed into code. Do not generate code and then mutate it. That will always be slower and less reliable.</p>',timeToRead:7,excerpt:"Defining Transformations Transformations allow Optic to convert one type of model into another (i.e. model -> route, route -> form). A…",frontmatter:{title:"Defining Transformations",cover:null,date:null,category:null,tags:null}},tableOfContents:{chapters:[{title:"What is Optic?",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/what-is-optic.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/what_is_optic/what-is-optic"},frontmatter:{title:"What Is Optic",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/another-code-generator.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/what_is_optic/another-code-generator"},frontmatter:{title:"Another Code Generator?",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/technical-overview.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/what_is_optic/technical-overview"},frontmatter:{title:"Technical Overview",type:null}}}}]},{title:"Using Optic",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/get-started.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/using/get-started"},frontmatter:{title:"Get Started",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/workflow.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/using/workflow"},frontmatter:{title:"Workflow",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/properties.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/using/properties"},frontmatter:{title:"Properties",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/search.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/using/search"},frontmatter:{title:"Search",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/transform.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/using/transform"},frontmatter:{title:"Transform",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/sync.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/using/sync"},frontmatter:{title:"Sync",type:null}}}}]},{title:"Extending Optic",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/extending-optic.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/extending-optic"},frontmatter:{title:"Extending Optic",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/writing-skills.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/writing-skills"},frontmatter:{title:"Writing Skills",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/knowledge-packages.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/knowledge-packages"},frontmatter:{title:"Knowledge Packages",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/lenses.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/writing-lenses"},frontmatter:{title:"Writing Lenses",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/transformations.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/defining-transformations"},frontmatter:{title:"Defining Transformations",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/schemas.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/defining-schemas"},frontmatter:{title:"Defining Schemas",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/publishing.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/publishing"},frontmatter:{title:"Publishing",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/adding-ides.md absPath of file",childMarkdownRemark:{fields:{slug:"/docs/authoring/adding-optic-support-for-new-id-es"},frontmatter:{title:"Adding Optic Support for new IDEs",type:null}}}}]}]},tableOfContentsSkills:{chapters:[{title:"Generate RequestJS calls for every route in an Express backend",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/skills/generate-requestjs.md absPath of file",childMarkdownRemark:{headings:[{value:"Generate RequestJS calls for every route in an Express backend",depth:1},{value:"Requirements",depth:2},{value:"Including Skills",depth:2},{value:"Our First Transform",depth:2},{value:"Generating Networking Calls from your Client Code",depth:2},{value:"Name and Source Annotations",depth:3},{value:"Syncing API & Networking Code",depth:2},{value:"Going Further",depth:2}],fields:{slug:"/skills/generate-request-js-calls-for-every-route-in-an-express-backend"},frontmatter:{title:"Generate RequestJS calls for every route in an Express backend",type:"skill"}}}}]}]}},pathContext:{slug:"/docs/authoring/defining-transformations",type:null}}}});
//# sourceMappingURL=path---docs-authoring-defining-transformations-a587b92ee0f3ac7ae9c7.js.map
webpackJsonp([5067510114144],{423:function(e,t){e.exports={data:{postBySlug:{html:'<h1 id="optic-not-just-another-code-generator"><a href="#optic-not-just-another-code-generator" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optic: Not Just Another Code Generator</h1>\n<p>Traditional code generators have a major technical limitation: they only work in one direction. This means they can only be used once and any addition, no matter how small, will break the ability to use that code generator again. </p>\n<p>These limitations are inconsequential when building compilers or tools for generating scaffolding, but they have handicapped most attempts to bring larger code generating projects mainstream. </p>\n<h1 id="optic-is-different"><a href="#optic-is-different" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optic is Different</h1>\n<p>Optic can read both your existing code and even modified generated code. It achieves this using machine learning to model the structure of programming languages and do complex pattern matching against code.</p>\n<p>Because Optic can read and generate code, it is far more useful than any past code generator. </p>\n<ol>\n<li>Optic can transform one kind of code into another, for instance a route into a form. The inputs don’t need to be specified when doing this because Optic can pull them from the code. </li>\n<li>Optic can sync your code. It creates a graph of all the parts of your code that relate to each other, and when one is changed, it automatically updates the others. Add a field to a table, for instance, and the routes, forms, and networking code will update. </li>\n<li>It works with existing code and can be used throughout the entire lifecycle of a project. </li>\n</ol>\n<h1 id="reformulating-the-code-generator"><a href="#reformulating-the-code-generator" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reformulating the Code Generator</h1>\n<blockquote>\n<p>How we turned a parser into a code generator </p>\n</blockquote>\n<p>At Optic we have reimagined the code generator. Historically, of these projects are a bunch of one-way functions called generators. These generators maps an input into a string or an AST Tree. </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Generator(Model) -&gt; Code</code></pre>\n      </div>\n<p>Most tools stop there and a) focus on neatly fitting into the compilation pipeline, b) extending their generators with plugins, or c) telling users to take over management of the generated code. </p>\n<p>Those who take on the round-trip problem<sup>1</sup> head on try and fail to build a generator and a parser that can read that code back into a model compatible with that generator. </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Generator(Model) -&gt; Code + Parser(code) -&gt; Model</code></pre>\n      </div>\n<p>This road does not lead anywhere fruitful. The round trip problem cannot be beaten, so it must be designed around.</p>\n<h1 id="code-as-the-source-of-truth"><a href="#code-as-the-source-of-truth" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code as the Source of Truth</h1>\n<p>When we set out to create a code generator programmers could collaborate with, it become obvious that traditional code generators had things backwards. These tools made their internal models the source of truth and then output code. Code generators are not useful if their input is more complicated than their output, so internal models tend to represent a subset of the functionality within their target programming languages. </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Model ⊂ Target Language</code></pre>\n      </div>\n<p>This further complicates the round-trip problem. Intuitively it makes sense that the model can be expanded into a larger representation, but it is not at all apparent how one would express richness of the target in a subset of itself. </p>\n<p>Programmers end up getting very unhappy when their needs outgrow the model. They know if they make manual changes they cannot use the tool anymore, but they also realize that they’ve gone beyond what the tool can do. The tool builder either acknowledges the futility of the problem and elects to makes a small niche code generator, or they try to build something so powerful “you never need to touch the code”...good luck. </p>\n<hr>\n<p>The solution is to make the code the absolute source of truth. This acknowledges the reality that, no matter how good our tools get, we will still need programmers to do some heavy lifting. Making the code the source of truth allows programmers to do that work, natively, in the abstraction most suited for it. </p>\n<p>In other words, instead of automating a few use cases well and making it impossible to code anything else, we choose to let you code anything you want while we automate a few use cases well. </p>\n<h1 id="a-new-equation"><a href="#a-new-equation" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A New Equation</h1>\n<p><strong>The Parser:</strong> If code is the source of truth, the focus moves from generating code to understanding the code that is already there. We do this by representing sections of code as ad-hoc models. As it parses code that defines a Rest Route, Optic pulls out the key values and creates a model that holds the URL, method, parameters, headers and response types. We can use this same ad-hoc model for Express, Spring, Flask, and other rest libraries across every language. </p>\n<p><strong>The Mutator:</strong> Once we have built a system capable of loosely reading code and pattern matching models, we can present those models to be edited in any way we like. If changes are made to that model, Optic patchs the original code, so it matches the updates. That patching is key. Because we have a parser and we know what our new code should parse as, we can do multiple passes until we get it right. With this feedback signal we can use ML to learn the best patches to suggest over time. </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Parser(code) -&gt; Model + Mutator(oldCode, model, newModel) -&gt; newCode</code></pre>\n      </div>\n<p>Now the big reveal: Instead of being based on Generators, Optic is the marriage of a Parser and a Mutator. If we can read code of a certain type and then mutate that section to express a new value, we have effectively bootstrapped a generator. But unlike traditional generators, ours will not erase your manual changes, comments, or other work a programmer has done. </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Generator == Parser + Mutator</code></pre>\n      </div>\n<h2 id="bottom-up-not-top-down"><a href="#bottom-up-not-top-down" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bottom Up, Not Top Down</h2>\n<p>Because Optic is based on parsing and mutation instead of generation, it builds its representation of code from the bottom up. This breaks with the monolithic mega-abstractions large code generators employ.</p>\n<p>Ad-hoc models with well defined responsibilities are easier to reason about and greatly simplify Optic. If you ask Optic to write a Create Route for one of your models it will tie together a routing library and whatever DB driver you’re using to write a section of code like this: </p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">app.post(‘/user’, function (req, res) {\n  new User({ \n   firstName: req.body.firstName,\n   lastName: req.body.lastName,\n   email: req.body.email,\n   age: req.body.age }).save((err, item) =&gt; {\n    if (!err) {\n        res.send(200, item)\n    } else {\n        res.send(400, err)\n    }\n  })\n})</code></pre>\n      </div>\n<p>If you then ask Optic to write a form for this route, Optic looks at the route and figures out what parameters need to be collected in the form. It does not care if you edit the query, delete it, or add some validation code above it. It elects to interpret that section of code as a Route so it pulls out only what it needs to know. This is what makes Optic so flexible and adaptive, and it is something that’s really difficult to emulate if you’re relying on a top-down, monolithic, abstraction. </p>\n<h2 id="the-code"><a href="#the-code" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Code</h2>\n<p>Optic is an Open Source project. If you’re interested in contributing or just checking out our code head over to our <a href="https://github.com/opticdev">Github</a>.</p>\n<ul>\n<li><a href="https://github.com/opticdev/optic">optic</a> - our core engine</li>\n<li><a href="https://github.com/opticdev/optic-markdown">optic-markdown</a> - a spec for human and machine readable docs (how Optic learns new kinds of code)</li>\n<li><a href="https://github.com/opticdev/marvin">marvin</a> - Learn the structure of a programming language from examples. </li>\n</ul>\n<hr/>\n## Footnotes\n### The Round-Trip Problem\nRound tripping models is practically impossible. Imagine two simple models for `Dog` and `Pet`. They are similar, so you’d think it would be easy to go back and forth, but immediately complications present themselves. \n<p>Dog: </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">name: String = Buster \ncolor: Color = Brown\nlength: Inches = 37\nwidth: Inches = 17\nbreed: Enum = Beagle\nbirthday: Date = 3/11/2014</code></pre>\n      </div>\n<p>Pet: </p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">petName: String \nownerName: String \ncolor: Color\nlength: Centimeters\nspecies: Enum\nage: Int</code></pre>\n      </div>\n<p>Converting Dog -> Pet (Failed)</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">petName = Buster    -- mapping of name -&gt; petName\nownerName = ???     -- not found\ncolor = Brown       -- copied \nlength = 93.98      -- length * 2.54\nspecies = Dog       -- getClass().name\nage = 4             -- Current Year - birthday.year</code></pre>\n      </div>\n<p>Fail one way: </p>\n<ol>\n<li>Required information in target can not be copied or computed. Example: <code class="language-text">ownerName</code></li>\n</ol>\n<p>Can be round-tripped: </p>\n<ol>\n<li>Mapping from property A -> B. Example <code class="language-text">petName</code>, <code class="language-text">color</code></li>\n<li>Mapping from property A &#x3C;-(function)-> B with a reversible function. Example <code class="language-text">length</code></li>\n</ol>\n<p>Work one way, but non-reversible: </p>\n<ol>\n<li>Mapping from property A -(function)> B. Example <code class="language-text">birthday</code> -> <code class="language-text">age</code></li>\n</ol>\n<p>Now imagine trying to get this to work for a model complicated enough to describe how an application is supposed to function</p>',timeToRead:6,excerpt:"Optic: Not Just Another Code Generator Traditional code generators have a major technical limitation: they only work in one direction. This…",frontmatter:{title:"Another Code Generator?",cover:null,date:null,category:null,tags:null}},tableOfContents:{chapters:[{title:"What is Optic?",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/what-is-optic.md absPath of file",childMarkdownRemark:{fields:{slug:"/what-is-optic"},frontmatter:{title:"What Is Optic",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/another-code-generator.md absPath of file",childMarkdownRemark:{fields:{slug:"/another-code-generator"},frontmatter:{title:"Another Code Generator?",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/technical-overview.md absPath of file",childMarkdownRemark:{fields:{slug:"/technical-overview"},frontmatter:{title:"Technical Overview",type:null}}}}]},{title:"Using Optic",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/get-started.md absPath of file",childMarkdownRemark:{fields:{slug:"/using-get-started"},frontmatter:{title:"Using Get Started",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/workflow.md absPath of file",childMarkdownRemark:{fields:{slug:"/workflow"},frontmatter:{title:"Workflow",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/properties.md absPath of file",childMarkdownRemark:{fields:{slug:"/properties"},frontmatter:{title:"Properties",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/search.md absPath of file",childMarkdownRemark:{fields:{slug:"/search"},frontmatter:{title:"Search",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/transform.md absPath of file",childMarkdownRemark:{fields:{slug:"/transform"},frontmatter:{title:"Transform",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/sync.md absPath of file",childMarkdownRemark:{fields:{slug:"/sync"},frontmatter:{title:"Sync",type:null}}}}]},{title:"Extending Optic",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/extending-optic.md absPath of file",childMarkdownRemark:{fields:{slug:"/extending-optic"},frontmatter:{title:"Extending Optic",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/writing-skills.md absPath of file",childMarkdownRemark:{fields:{slug:"/writing-skills"},frontmatter:{title:"Writing Skills",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/knowledge-packages.md absPath of file",childMarkdownRemark:{fields:{slug:"/knowledge-packages"},frontmatter:{title:"Knowledge Packages",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/lenses.md absPath of file",childMarkdownRemark:{fields:{slug:"/writing-lenses"},frontmatter:{title:"Writing Lenses",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/transformations.md absPath of file",childMarkdownRemark:{fields:{slug:"/defining-transformations"},frontmatter:{title:"Defining Transformations",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/schemas.md absPath of file",childMarkdownRemark:{fields:{slug:"/defining-schemas"},frontmatter:{title:"Defining Schemas",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/publishing.md absPath of file",childMarkdownRemark:{fields:{slug:"/publishing"},frontmatter:{title:"Publishing",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/adding-ides.md absPath of file",childMarkdownRemark:{fields:{slug:"/adding-optic-support-for-new-id-es"},frontmatter:{title:"Adding Optic Support for new IDEs",type:null}}}}]}]},tableOfContentsSkills:{chapters:[{title:"Generate RequestJS calls for every route in an Express backend",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/skills/generate-requestjs.md absPath of file",childMarkdownRemark:{headings:[{value:"Generate RequestJS calls for every route in an Express backend",depth:1},{value:"Requirements",depth:2},{value:"Including Skills",depth:2},{value:"Our First Transform",depth:2},{value:"Generating Networking Calls from your Client Code",depth:2},{value:"Name and Source Annotations",depth:3},{value:"Syncing API & Networking Code",depth:2},{value:"Going Further",depth:2}],fields:{slug:"/generate-request-js-calls-for-every-route-in-an-express-backend"},frontmatter:{title:"Generate RequestJS calls for every route in an Express backend",type:"skill"}}}}]}]}},pathContext:{slug:"/another-code-generator",type:null}}}});
//# sourceMappingURL=path---another-code-generator-e972a26719d5eebbf225.js.map
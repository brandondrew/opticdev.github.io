webpackJsonp([0x8427a4778776],{453:function(e,n){e.exports={data:{postBySlug:{html:'<h1 id="defining-transformations"><a href="#defining-transformations" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining Transformations</h1>\n<p>Transformations allow Optic to convert one type of model into another (i.e. model -> route, route -> form). A Transformation is just a pure Javascript function that takes one type of Schema and returns another.</p>\n<p>Every Transformation needs a <code class="language-text">name</code> field. We suggest using “->” as part of your name to indicate what the entity and result of the Transformation are supposed to be. Transformations also get an <code class="language-text">input</code> and <code class="language-text">output</code> field which are references to the Schemas they consume and return.</p>\n<p>The code block for a Transformation must contain a function named <code class="language-text">Transform</code>. This function will receive a model that is the same type as <code class="language-text">input</code> and will return a model of type <code class="language-text">output</code>. If the function returns an object that doesn’t conform to type output or if the code throws an exception, the Transformation will not do anything.</p>\n<div class="gatsby-highlight">\n      <pre class="language-markdown"><code class="language-markdown"><span class="token comment">&lt;!-- Transformation-def\nyields=“Schema -> Create Route”\nid="SchemaToRoute"\ninput=“Schema”\noutput=“optic:rest/route” --></span>\n```Javascript\nfunction Transform(input) {\n<span class="token code keyword">    const routeName = input.name.toLowerCase()</span>\n<span class="token code keyword">    const route = “/“+routeName</span>\n\n<span class="token code keyword">    const parameters = Object.keys(input.Schema).map(i=> {</span>\n<span class="token code keyword">        return {</span>\n<span class="token code keyword">            in: ‘body’,</span>\n<span class="token code keyword">            name: i</span>\n<span class="token code keyword">        }</span>\n<span class="token code keyword">    })</span>\n\n<span class="token code keyword">    return {</span>\n<span class="token code keyword">        method: “post”,</span>\n<span class="token code keyword">        url: route,</span>\n<span class="token code keyword">        parameters</span>\n<span class="token code keyword">    }</span>\n}\n```</code></pre>\n      </div>\n<h2 id="asking-for-additional-information"><a href="#asking-for-additional-information" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asking for Additional Information</h2>\n<p>Some Transformations will require more information than what you find in its input Schema. For instance, when generating a route, you might want to offer a flag for <code class="language-text">authenticated</code> that affects how that route is rendered.</p>\n<p>Optic Markdown supports asking for additional information through its Ask API. You can ask for a primitive value, a Lens or a Schema by placing an ask call above of your <code class="language-text">Transform</code> function. Optic converts these ask calls into an anonymous Schema that users have to respond to in the Editor Window after they select the Transformation.</p>\n<p>The first argument to all of the ask functions is the name of the field. We suggest you make it a valid JS token, so you can reference it with dot notation in your <code class="language-text">Transform</code> function.</p>\n<p>The second field is a description. Use this field to give users the details they need to properly answer your questions and inform them of how this information will be used.</p>\n<p>When calling <code class="language-text">forPrimitive</code>, the 3rd argument is required and defines the type you must answer with. Right now <code class="language-text">boolean</code>, <code class="language-text">string</code>, and <code class="language-text">number</code> are allowed. These types follow the same semantics as they do in the <a href="http://json-Schema.org/">JSON Schema</a> Spec.</p>\n<p>When calling <code class="language-text">forlens</code>, the 3rd argument is optional and allows you to filter the Lenses you can answer with to ones that render a certain Schema. There’s a one-to-many relationship between Schemas and Lenses, so often a Transformation will need to ask users which Lens they would like to render the result with. Naturally if you are Transforming something into a Rest Route, you only want to employ Lenses capable of doing that.</p>\n<p>** Using Answers:**\nAll answers are added to an object which is passed into the <code class="language-text">Transform</code> function as the second argument. You can access them with dot or bracket notation as you would any other property.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">ask.forPrimitive(‘ask1’, ‘Description here...’, ‘string’)\nask.forLens(‘ask2’, ‘Description here...’, ‘test:package/Schema’)\nask.forSchema(‘ask3’, ‘Description here...’)\nfunction Transform(input, answers) {\n  answers.ask1 //a primitive of the specified type\n  answers.ask2 //the ID of a compiled Lens, guaranteed to render specified Schema\n  answers.ask3 //a Schema reference\n...\n}</code></pre>\n      </div>\n<h2 id="nested-transformations"><a href="#nested-transformations" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested Transformations</h2>\n<p>** The Need: ** Most practical Transformations aren’t going to rely on just one type of Schema or Lens. For instance Routes contain validation, queries, error handling, and responses. It would be tedious if users had to Transform a model into each of those components individually. The current convention is to make larger abstractions RouteWithValidationAndQueryAndResponse, but big abstractions and brittle and go against our design principles.</p>\n<p>Optic addresses this need by allowing users to tap into our internal Render system. Instead of returning a simple model from the <code class="language-text">Transform</code> function, there is an option to return a request for our internal Render system to do something more complex.</p>\n<p>There’s a Generate function in the global scope that you can call from your Transformation.\n<code class="language-text">Generate(SchemaRef, value, {...options})</code></p>\n<ul>\n<li>Schema Reference - The reference to the Schema you would like to render</li>\n<li>value - The value (must conform to the above Schema)</li>\n<li>options - Allow you to configure the render (see below)</li>\n</ul>\n<p>If you return <code class="language-text">Generate(‘optic:js/import’, {definedAs: ‘hello’, pathTo: ‘world’})</code> from your Transform function, Optic will write <code class="language-text">import hello from ‘world’</code> in your code.</p>\n<h3 id="render-options"><a href="#render-options" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Render Options</h3>\n<table>\n<thead>\n<tr>\n<th>field</th>\n<th>default</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gearID (optional)</td>\n<td>1st Lens found with Schema</td>\n<td>The ID of the Lens you want to render with. Never hardcode these. Always ask users.</td>\n</tr>\n<tr>\n<td>containers (optional)</td>\n<td>Empty Object</td>\n<td>A map of container names -> \n[\nStagedNode..\n]\n. Use this to fill a Lens container with your own staged nodes. They will be rendered in the order of the array you provide</td>\n</tr>\n<tr>\n<td>variables (optional)</td>\n<td>Empty Object</td>\n<td>A map of variable names and the string value you want them to render with. (ie: {model: ‘user’}) Note that these are implicitly passed from parents to children. So if you set them at the top-most call to \n<code class="language-text">Generate</code>\n they will be passed down the tree and merged/overridden by any variables you set in those children.</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Full Example:</strong>\nModel -> Route Transformation with nested queries and responses.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">ask.forLens(‘queryProvider’, ‘The Lens your want to use for your create query’, ‘optic:query/create-record’)\nfunction Transform(input, answers) {\n    var routeName = input.name.toLowerCase();\n\n    var route = “/“ + routeName;\n    var parameters = Object.keys(input.Schema).map(function(i) {\n        return { in: ‘body’,\n            name: i\n        };\n    });\n    var routeDescription = {\n        method: “post”,\n        url: route,\n        parameters: parameters\n    };\n    var queryDescription = {\n        fields: Object.keys(input.Schema).reduce(function(previous, current) {\n            previous[current] = Generate(‘optic:rest/parameter’, { in: ‘body’,\n                name: current\n            });\n            return previous;\n        }, {})\n    };\n\n    const newItemVariable = ‘item’\n\n    return Generate(answers.output, routeDescription, {\n        containers: {\n            “callback”: [Generate(‘optic:mongoose/create-record’, queryDescription, {\n                gearId: answers.queryProvider\n                containers: {\n                  “success”: [\n                    Generate(‘optic:rest/response’, {status: 200}, {\n                      ‘variables’: {\n                        ‘returnObject’: newItemVariable\n                      }\n                    })\n                  ],\n                  “failure”: [\n                    Generate(‘optic:rest/response’, {status: 400})\n                  ]\n                },\n                ‘variables’: {\n                  ‘newObject’: newItemVariable\n                }\n            })]\n        }\n    });\n}</code></pre>\n      </div>\n<p>Input Code:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">const toDo = mongoose.model(‘todo’, new mongoose.Schema({\n    ‘message’: ‘string’,\n    ‘isDone’: ‘string’\n}))</code></pre>\n      </div>\n<p>Transformed into Create Route:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">app.post(‘/todo’, (req, res)=&gt; {\n  new toDo({\n    message: req.body.message,\n    isDone: req.body.isDone\n  }).save((err, item)=&gt; {\n    if (!err) {\n      res.send(200, item)\n    } else {\n      res.send(400, err)\n    }\n  })\n})</code></pre>\n      </div>',timeToRead:5,excerpt:"Defining Transformations Transformations allow Optic to convert one type of model into another (i.e. model -> route, route -> form). A…",frontmatter:{title:"Transformations",cover:null,date:null,category:null,tags:null}},tableOfContents:{chapters:[{title:"What is Optic?",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/another-code-generator.md absPath of file",childMarkdownRemark:{fields:{slug:"/another-code-generator"},frontmatter:{title:"Another Code Generator?",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/technical-overview.md absPath of file",childMarkdownRemark:{fields:{slug:"/technical-overview"},frontmatter:{title:"Technical Overview",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/ontology.md absPath of file",childMarkdownRemark:{fields:{slug:"/optics-ontology"},frontmatter:{title:"Optic's Ontology",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/what_is_optic/markdown.md absPath of file",childMarkdownRemark:{fields:{slug:"/optic-markdown"},frontmatter:{title:"Optic Markdown",type:null}}}}]},{title:"Using Optic",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/get-started.md absPath of file",childMarkdownRemark:{fields:{slug:"/using-get-started"},frontmatter:{title:"Using Get Started",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/workflow.md absPath of file",childMarkdownRemark:{fields:{slug:"/workflow"},frontmatter:{title:"Workflow",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/properties.md absPath of file",childMarkdownRemark:{fields:{slug:"/properties"},frontmatter:{title:"Properties",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/search.md absPath of file",childMarkdownRemark:{fields:{slug:"/search"},frontmatter:{title:"Search",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/transform.md absPath of file",childMarkdownRemark:{fields:{slug:"/transform"},frontmatter:{title:"Transform",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/using/sync.md absPath of file",childMarkdownRemark:{fields:{slug:"/sync"},frontmatter:{title:"Sync",type:null}}}}]},{title:"Authoring Knowledge",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/get-started.md absPath of file",childMarkdownRemark:{fields:{slug:"/authoring-get-started"},frontmatter:{title:"Authoring Get Started",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/knowledge-packages.md absPath of file",childMarkdownRemark:{fields:{slug:"/knowledge-packages"},frontmatter:{title:"Knowledge Packages",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/schemas.md absPath of file",childMarkdownRemark:{fields:{slug:"/schemas"},frontmatter:{title:"Schemas",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/lenses.md absPath of file",childMarkdownRemark:{fields:{slug:"/lenses"},frontmatter:{title:"Lenses",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/transformations.md absPath of file",childMarkdownRemark:{fields:{slug:"/transformations"},frontmatter:{title:"Transformations",type:null}}}},{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/lessons/authoring/publishing.md absPath of file",childMarkdownRemark:{fields:{slug:"/publishing"},frontmatter:{title:"Publishing",type:null}}}}]}]},tableOfContentsSkills:{chapters:[{title:"Generate RequestJS calls for every route in an Express backend",entries:[{entry:{id:"/Users/aidancunniffe/Desktop/optic-homepage/content/skills/generate-requestjs.md absPath of file",childMarkdownRemark:{headings:[{value:"Generate RequestJS calls for every route in an Express backend",depth:1},{value:"Requirements",depth:2},{value:"Including Skills",depth:2},{value:"Our First Transform",depth:2},{value:"Generating Networking Calls from your Client Code",depth:2},{value:"Name and Source Annotations",depth:3},{value:"Syncing API & Networking Code",depth:2},{value:"Going Further",depth:2}],fields:{slug:"/generate-request-js-calls-for-every-route-in-an-express-backend"},frontmatter:{title:"Generate RequestJS calls for every route in an Express backend",type:"skill"}}}}]}]}},pathContext:{slug:"/transformations",type:null}}}});
//# sourceMappingURL=path---transformations-532edc0f584ed4570670.js.map